"""
2021.02.28
Andrew Ng - Deep Learning
Chater 4. CNN
Week 1. Convolutional Neural Networks

"""


"""
1. Computer Vision
딥러닝은 여러 분야에서 새로운 지평을 여는 중이다.

Computer Vision Problems
In image classification,
 1) 고양이인지 아닌지
 2) 사물 감지 ex - 자동차와 같은 물체가 있는지, 어느 위치에 있는지
 3) 한 사진을 다른 스타일로 바꾸기 ex - 인물 사진을 피카소 풍으로
  
컴퓨터 비전의 큰 장애물 중 하나는, 입력의 크기가 너무 클 수 있다는 것.
1장의 사진 = 64 * 64 * 3(RGB) = 12288 이지만
64 * 64 크기의 사진은 굉장히 작다.
만약 1000 * 1000의 크기, 즉 1 메가 픽셀이라면 크기는 300만일 것이고
2번째 층에는 1000개의 은닉 유닛이 있으며
1번째 층의 가중치는 (1000, 3m) 행렬일 것이다. (3억개의 변수)
이렇게 변수가 많아지면 충분한 데이터를 얻어 과적합을 방지하기 어렵다.





2. Edge Detection Examples
모서리 감지를 통해 합성곱하는 법을 알아보자.
우선, 사진에서 수직의 모서리와 수평의 모서리를 감지해야 한다.
수직의 모서리를 감지하기 위해서는
6 * 6 그레이스케일이 있을 때, 3 * 3의 필터를 만든 뒤,
1 0 -1
1 0 -1
1 0 -1 의 값을 입력한 뒤 합성곱해준다.
그 결과물은 4 * 4가 된다.
python : conv_forward
tensorflow : tf.nn.conv2d
keras : conv2D 로 할 수 있다.

 
 


3. More Edge Detection
수평의 윤곽선을 감지해보자.
1   1   1
0   0   0
-1 -1  -1 필터로 할 수 있다.

1 0 -1
2 0 -2
1 0 -1 은  Sobel filter로,
장점은 중간 부분의 픽셀에 더 중점을 두어 더 선명해보인다는 것이다.

3  0 -3
10 0 -10
3  0 -3 은 Scharr filter이다.

filter 안의 숫자를 변수로 두어 역전달의 방식으로
스스로 가장 좋은 윤곽선 검출기가 무엇인지 찾게 할 수 있다.
9개의 숫자를 모두 변수로 두어보자. 





4. Padding
n * n의 이미지가 있을 때, f * f의 필터를 합성곱하면
그 결과는 (n - f + 1) * (n - f + 1) 이다.
단점은 이미지에 필터를 합성곱할 때마다 그 크기가 줄어든다는 것이다.
또, 가장자리의 픽셀은 단 1번만 사용되어 다른 픽셀보다 결과 이미지에 덜 사용된다.
이 두 문제를 해결하기 위해서 padding을 사용한다.
합성곱하기 전, 가장자리에 1픽셀만큼 둘러서 더해주면
6 * 6 이미지는 8 * 8이 되고 결과또한 6 * 6이 된다.
더한 픽셀의 값은 보통 0으로 한다.
원한다면 2픽셀만큼 padding 할 수도 있다.

패딩을 얼마만큼 할 것이냐에는
1) 유효합성곱
2) 동일합성곱의 두가지 방법이 있다.

유효합성곱이란 패딩이 없는 것으로,
6 * 6의 이미지에 3 * 3 필터를 합성곱하여 4 * 4의 결과물을 얻는다.
동일합성곱이란 패딩을 두른 것으로,
합성곱한 뒤 결과물의 크기가 패딩을 두르기 전 이미지의 크기와 동일하다.

일반적으로 컴퓨터비전에서 filter의 크기는 보통 홀수이다.
만약 f가 짝수라면 패딩이 비대칭이 되어
왼쪽과 오른쪽이 서로 다르게 패딩해주어야 한다.
또, f가 홀수라면 중앙 픽셀이 존재하기 때문에 좋다.





5. Strided Convolutions
7 * 7 이미지를 3 * 3 필터로 합성곱 해보자.
일반적인 방법 대신 stride = 2로 해보자.
이것은 행과 열을 이동하며 필터를 곱해줄 때, 1칸씩이 아닌 2칸씩 이동하는 것이다.
결과물은 3 * 3 행렬일 것이다.
일반화하면, (n+2p-f / s) + 1 * (n+2p-f / s) + 1 가 된다.
n = 이미지의 크기, p = 패딩, f = 필터, s = stride 이다.

원래의 수학적 합성곱에서는 필터를 합성곱하기 전에
필터의 가로축과 세로축을 뒤집어준다.(미러링)
딥러닝에서의 합성곱은 이 단계가 생략되어 cross-correlation(교차상관)이라 불러야하지만
관습적으로 합성곱이라 부르는 것이다.



 
 
6. Convolutions Over Volumes
RGB 이미지에서 6*6*3 이라면 이미지의 크기는 6*6, RGB가 3인 더미.
이 이미지의 윤곽선을 검출하려면 이전의 3*3 필터 대신 3*3*3인 3d 필터를 사용해야한다.
height * width * #channels 의 크기를 가질 때, 채널의 숫자는 반드시 같아야 한다.
결과 이미지는 4*4*1 이 된다.

빨간색 채널의 세로 윤곽선을 검출하고 싶을 때엔, 필터의 값을
1 0 -1     0 0 0      0 0 0
1 0 -1     0 0 0      0 0 0
1 0 -1     0 0 0      0 0 0  으로 설정하면 되고

모든 색의 세로 윤곽선을 검출하고 싶을 때엔, (세로선이 어떤 색이던 관계 없다면)
1 0 -1     1 0 -1     1 0 -1
1 0 -1     1 0 -1     1 0 -1
1 0 -1     1 0 -1     1 0 -1  으로 설정하면 된다.

 
 
 
 
7. One Layer of a Convolutional Net
6 * 6 * 3 이미지에 두 개의 3 * 3 * 3 필터를 각각 합성곱하여
4 * 4 의 결과물 2개를 얻었다.
결과물에 각각 실수인 편향 b1, b2을 16개의 요소에 따로따로 더해주고
Relu 비선형성을 적용해주면 새로운 4 * 4 가 나온다.
이 새로운 결과물 두개를 합쳐 쌓은 것(4 * 4 * 2)이 합성곱 신경망의 한 계층이 된다.





8. Simple Convolutional Network Example
39 * 39 * 3 이미지가 있을 때, 3 * 3 필터 10개를 적용하여 (패딩 x, stride = 1)
37 * 37 * 10 의 결과물을 얻고 이것에 다시 5 * 5 필터 20개를 적용하면 (패딩 x, s = 2)
17 * 17 * 20 의 결과물을 얻는다.
여기에 다시 5 * 5 필터 (패딩 x, s = 2) 40개를 적용하면 7 * 7 * 40 을 얻는다.

신경망이 깊어질 수록 채널의 수는 늘어나고 이미지의 크기는 작아지는 것을 알 수 있다.

일반적인 합성곱 신경망에는 세 종류의 층이 있다.
1) Convolution layer (CONV)
2) Pooling (POOL)
3) Fully connected (FC)





9. Pooling Layers
합성곱 신경망은 풀링층을 사용하여 표현 크기를 줄임으로써
계산속도를 높이고 특성을 훨씬 더 잘 검출할 수 있다.

4 * 4 입력에, 최대 풀링을 구현한다면 출력은 2 * 2 이다.
입력을 여러 구간으로 나누고 각 구간의 최대값으로 출력을 구성한다.
왜 신경망에서 최대 풀링이 효과가 좋은지는 아직 완전히 밝혀지진 않았으나
한 가지 흥미로운 점은 여러 하이퍼파라미터가 있지만 학습할 수 있는 변수가 없다는 것이다.
f, s는 고정된 값이라 경사하강으로 학습할 수 없다.

5 * 5 의 입력에 f = 3, s = 1 일 때 출력은 3 * 3 이다.
합성곱 공식과 동일하게 최대 풀링에서도 (n + 2p -f / s) + 1 의 공식을 사용한다.
3차원 입력이라면 출력또한 같은 모양을 가진다.
5 * 5 * 2 일 때, 출력은 3 * 3 * 2 가 된다.

평균 풀링은 잘 사용되지 않지만, 각 구간의 최대값이 아닌 평균값으로 출력을 구성한다.
풀링은 학습할 파라미터가 없는 고정함수이다.





10. CNN Example
32 * 32 * 3 의 RGB 이미지가 있을 때, 이미지엔 7이 적혀있고
0 부터 9까지의 손글씨를 인식해야 한다.
CONV1 층에서, 
5 * 5 의 필터(s = 1) 6개를 적용하면 28 * 28 * 6 의 출력을 얻고
POOL1 층에서,
최대 풀링(f = 2, s = 2)를 적용하면 14 * 14 * 6 의 출력을 얻는다.
CONV1과 POOL2은 하나의 층으로, 현재는 Layer 1이다.

이후 CONV2 층에서, 
5 * 5 필터(f = 5, s = 1) 16개를 적용하면 10 * 10 * 16 의 출력을
POOL2 층에서,
최대 풀링(f = 2, s = 2)를 적용하면 5 * 5 * 16 의 출력을 얻는다.
CONV2와 POOL2는 하나의 층으로, 현재는 Layer 2이다.

다음으로는 5 * 5 * 16 을 400 * 1 의 벡터로 펼친 뒤,
120 개의 유닛을 가진 층을 만든다. 이것이 첫번째 Fully connected 층인 FC3이다.
이 층의 가중치 행렬 w[3]는 (120, 400)이고 편향 변수 b는 (120)이다.

마지막으로 FC4 층에서는 120개의 유닛에 좀 더 작은 층을 더해보자.
84개의 유닛을 만들고 소프트맥스 유닛에 적용한다.
최종적으로 0 부터 9 까지 10개의 출력이 만들어진다.





11. Why Convolutions
합성곱 층을 이용할 때의 장점 2가지
1) 변수 공유
2) 희소 연결



 
 
"""